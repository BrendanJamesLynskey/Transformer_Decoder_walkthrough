<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Transformer Decoder ‚Äî Every Computation, From Scratch</title>
<meta name="description" content="Interactive walkthrough of every operation inside a GPT-style autoregressive transformer decoder. All computations run live in your browser.">
<style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600;700&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap');

  :root {
    --bg: #0a0e17;
    --surface: #111827;
    --surface-hover: #1a2235;
    --border: #1e2a3a;
    --border-hi: #2d4a6f;
    --text: #c9d1d9;
    --text-dim: #6b7a8d;
    --text-bright: #e6edf3;
    --accent: #58a6ff;
    --accent-dim: #1a3a5c;
    --green: #3fb950;
    --green-dim: #1a3328;
    --orange: #d29922;
    --orange-dim: #3d2e0a;
    --red: #f85149;
    --purple: #bc8cff;
    --purple-dim: #2a1f3d;
    --cyan: #39d2c0;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'IBM Plex Sans', 'Segoe UI', system-ui, sans-serif;
    line-height: 1.6;
    -webkit-font-smoothing: antialiased;
  }

  #root { max-width: 880px; margin: 0 auto; padding: 32px 20px 64px; }

  .header-label {
    font-size: 11px; text-transform: uppercase; letter-spacing: 3px;
    color: var(--accent); font-family: 'IBM Plex Mono', monospace; margin-bottom: 8px;
  }
  h1 {
    font-size: 28px; font-weight: 700; color: var(--text-bright);
    font-family: 'IBM Plex Mono', monospace; line-height: 1.3; margin-bottom: 4px;
  }
  h1 .sub { color: var(--text-dim); font-weight: 400; font-size: 18px; }
  .intro { color: var(--text-dim); font-size: 13.5px; margin-top: 12px; line-height: 1.65; max-width: 700px; }
  .tags { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 14px; }

  .tag {
    display: inline-block; padding: 2px 8px; border-radius: 4px;
    font-family: 'IBM Plex Mono', monospace; font-size: 12px;
    background: rgba(88,166,255,0.08); color: var(--accent);
    border: 1px solid rgba(88,166,255,0.2);
  }
  .tag.cyan { background: rgba(57,210,192,0.08); color: var(--cyan); border-color: rgba(57,210,192,0.2); }
  .tag.orange { background: rgba(210,153,34,0.08); color: var(--orange); border-color: rgba(210,153,34,0.2); }

  .section {
    margin-bottom: 16px; border: 1px solid var(--border);
    border-radius: 8px; overflow: hidden; background: var(--surface);
  }
  .section-header {
    width: 100%; display: flex; align-items: center; gap: 10px;
    padding: 14px 18px; background: transparent; border: none;
    color: var(--text-bright); cursor: pointer; font-size: 15px; font-weight: 600;
    font-family: 'IBM Plex Mono', monospace; text-align: left;
    border-bottom: 1px solid transparent; transition: background 0.15s;
  }
  .section-header:hover { background: var(--surface-hover); }
  .section-header.open { background: var(--surface-hover); border-bottom-color: var(--border); }
  .section-header .emoji { font-size: 18px; }
  .section-header .title { flex: 1; }
  .section-header .arrow {
    color: var(--text-dim); font-size: 13px;
    transition: transform 0.15s; display: inline-block;
  }
  .section-header.open .arrow { transform: rotate(90deg); }
  .section-body { padding: 16px 18px; }

  .prose { color: var(--text); font-size: 13.5px; line-height: 1.7; margin: 6px 0; }
  .prose strong { color: var(--text-bright); }

  .math-block {
    background: var(--purple-dim); border: 1px solid rgba(188,140,255,0.2);
    border-radius: 6px; padding: 10px 14px; font-family: 'IBM Plex Mono', monospace;
    font-size: 13px; color: var(--purple); margin: 10px 0; text-align: center;
    overflow-x: auto;
  }

  .code-block {
    background: var(--bg); border: 1px solid var(--border); border-radius: 6px;
    padding: 12px 14px; font-family: 'IBM Plex Mono', monospace; font-size: 12px;
    color: var(--green); overflow-x: auto; margin: 8px 0; line-height: 1.55;
    white-space: pre; tab-size: 2;
  }

  .output {
    background: #0d1117; border-left: 3px solid var(--accent);
    border-radius: 0 6px 6px 0; padding: 10px 14px;
    font-family: 'IBM Plex Mono', monospace; font-size: 11.5px;
    color: var(--text); overflow-x: auto; margin: 8px 0;
    line-height: 1.55; white-space: pre-wrap;
  }

  .causal-mask { font-family: 'IBM Plex Mono', monospace; font-size: 11px; margin: 8px 0; }
  .cm-ok { color: var(--green); }
  .cm-block { color: var(--red); }

  .heatmap-wrap { overflow-x: auto; display: flex; flex-wrap: wrap; gap: 4px; margin: 8px 0; }
  .heatmap-label { font-size: 10px; color: var(--text-dim); font-family: 'IBM Plex Mono', monospace; margin-bottom: 2px; }
  .heatmap-grid { display: inline-grid; gap: 1px; }
  .heatmap-cell {
    display: flex; align-items: center; justify-content: center;
    border-radius: 2px; font-family: 'IBM Plex Mono', monospace;
  }

  .bar-row { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; font-family: 'IBM Plex Mono', monospace; font-size: 11px; }
  .bar-label { width: 30px; color: var(--text-dim); text-align: right; }
  .bar-fill { height: 14px; border-radius: 2px; background: linear-gradient(90deg, var(--accent), var(--cyan)); min-width: 1px; transition: width 0.3s; }
  .bar-value { color: var(--text-dim); }

  .gen-btn {
    padding: 10px 24px;
    background: linear-gradient(135deg, var(--accent), var(--cyan));
    color: #000; border: none; border-radius: 6px; font-size: 14px;
    font-weight: 700; font-family: 'IBM Plex Mono', monospace;
    cursor: pointer; letter-spacing: 0.5px; margin: 12px 0;
    transition: opacity 0.15s;
  }
  .gen-btn:hover { opacity: 0.9; }

  .token-chip {
    display: inline-block; padding: 4px 10px; border-radius: 4px;
    font-family: 'IBM Plex Mono', monospace; font-size: 13px; font-weight: 600;
  }
  .token-chip.input { background: var(--accent-dim); color: var(--accent); border: 1px solid rgba(88,166,255,0.27); }
  .token-chip.generated { background: var(--green-dim); color: var(--green); border: 1px solid rgba(63,185,80,0.27); }

  .takeaway {
    display: flex; gap: 12px; padding: 10px 14px; border-radius: 6px; margin-bottom: 6px;
  }
  .takeaway-num { font-weight: 700; font-size: 14px; font-family: 'IBM Plex Mono', monospace; min-width: 20px; }
  .takeaway-title { font-weight: 600; font-size: 13px; margin-bottom: 2px; }
  .takeaway-desc { color: var(--text-dim); font-size: 12.5px; }

  .footer {
    margin-top: 16px; padding: 12px 16px; background: var(--bg);
    border-radius: 6px; border: 1px solid var(--border); font-size: 12px;
    color: var(--text-dim); font-family: 'IBM Plex Mono', monospace; text-align: center;
  }

  /* ‚îÄ‚îÄ Architecture Diagram ‚îÄ‚îÄ */
  .arch-diagram {
    display: flex; justify-content: center; padding: 4px 0;
  }
  .arch-flow {
    display: flex; flex-direction: column; align-items: center; width: 100%;
  }
  .arch-arrow { display: flex; justify-content: center; margin: 2px 0; }
  .arch-inner-arrow { display: flex; justify-content: center; margin: 4px 0; }

  .arch-node {
    width: 100%; max-width: 520px; padding: 12px 18px; border-radius: 8px;
    text-align: center; position: relative;
    font-family: 'IBM Plex Mono', monospace;
  }
  .arch-node-label {
    font-size: 9px; text-transform: uppercase; letter-spacing: 2px;
    color: var(--text-dim); margin-bottom: 2px;
  }
  .arch-node-title { font-size: 14px; font-weight: 700; color: var(--text-bright); }
  .arch-node-detail { font-size: 11.5px; color: var(--text-dim); margin-top: 2px; }
  .arch-node-shape {
    display: inline-block; font-size: 10px; color: var(--cyan); opacity: 0.8;
    background: rgba(57,210,192,0.07); padding: 1px 6px; border-radius: 3px; margin-top: 4px;
  }
  .arch-node-icon {
    position: absolute; top: 8px; left: 12px; font-size: 10px;
    color: var(--accent); opacity: 0.6; font-weight: 600;
  }

  .arch-input {
    background: linear-gradient(135deg, rgba(88,166,255,0.1), rgba(88,166,255,0.04));
    border: 1px solid rgba(88,166,255,0.2);
  }
  .arch-embed {
    background: linear-gradient(135deg, rgba(188,140,255,0.08), rgba(188,140,255,0.03));
    border: 1px solid rgba(188,140,255,0.18);
  }
  .arch-result {
    background: linear-gradient(135deg, rgba(63,185,80,0.1), rgba(63,185,80,0.04));
    border: 1px solid rgba(63,185,80,0.2);
  }

  .arch-layer-wrap {
    width: 100%; max-width: 560px; position: relative;
  }
  .arch-layer-badge {
    position: absolute; top: -9px; right: 16px; z-index: 2;
    font-size: 10px; font-weight: 700; font-family: 'IBM Plex Mono', monospace;
    color: var(--orange); background: var(--surface);
    padding: 1px 10px; border-radius: 4px;
    border: 1px solid rgba(210,153,34,0.3);
  }
  .arch-layer {
    border: 1.5px solid rgba(210,153,34,0.25); border-radius: 10px;
    padding: 18px 14px 14px; background: rgba(210,153,34,0.02);
  }

  .arch-sublayer { margin-bottom: 2px; }
  .arch-sublayer-header {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 8px;
  }
  .arch-sublayer-tag {
    font-size: 11px; font-weight: 700; font-family: 'IBM Plex Mono', monospace;
    padding: 2px 10px; border-radius: 4px;
  }
  .attn-tag {
    color: var(--accent); background: rgba(88,166,255,0.1);
    border: 1px solid rgba(88,166,255,0.15);
  }
  .ffn-tag {
    color: var(--green); background: rgba(63,185,80,0.1);
    border: 1px solid rgba(63,185,80,0.15);
  }
  .arch-residual-badge {
    font-size: 10px; color: var(--text-dim); font-family: 'IBM Plex Mono', monospace;
    padding: 1px 8px; border-radius: 3px; border: 1px dashed var(--border);
  }

  .arch-step-grid { display: flex; flex-direction: column; gap: 3px; }
  .arch-step {
    display: flex; align-items: baseline; gap: 8px;
    padding: 4px 10px; border-radius: 5px;
    background: rgba(255,255,255,0.02); border: 1px solid var(--border);
    font-family: 'IBM Plex Mono', monospace;
  }
  .arch-step:hover { background: rgba(255,255,255,0.04); border-color: var(--border-hi); }
  .arch-step-ref {
    font-size: 9px; color: var(--accent); opacity: 0.5; font-weight: 600; min-width: 16px;
  }
  .arch-step-name { font-size: 12px; color: var(--text-bright); font-weight: 600; }
  .arch-step-info { font-size: 10.5px; color: var(--text-dim); margin-left: auto; }

  .arch-output-stack { max-width: 560px; width: 100%; padding: 0; }
  .arch-output-row {
    display: flex; align-items: center; justify-content: center;
    gap: 6px; flex-wrap: wrap;
  }
  .arch-output-arr { color: var(--text-dim); font-size: 16px; }
  .arch-mini-node {
    padding: 8px 14px; border-radius: 6px; text-align: center;
    font-family: 'IBM Plex Mono', monospace; font-size: 12px;
    font-weight: 600; color: var(--text-bright);
  }
  .norm-node {
    background: rgba(188,140,255,0.07); border: 1px solid rgba(188,140,255,0.18);
  }
  .head-node {
    background: rgba(88,166,255,0.07); border: 1px solid rgba(88,166,255,0.18);
  }
  .sample-node {
    background: rgba(57,210,192,0.07); border: 1px solid rgba(57,210,192,0.18);
  }

  @media (max-width: 600px) {
    .arch-output-row { flex-direction: column; }
    .arch-output-arr { transform: rotate(90deg); }
    .arch-step-info { margin-left: 0; display: block; width: 100%; margin-top: 2px; }
    .arch-step { flex-wrap: wrap; }
  }

  /* ‚îÄ‚îÄ Causal Mask Grid ‚îÄ‚îÄ */
  .causal-grid-wrap {
    display: inline-block; margin: 10px 0; padding: 8px;
    background: var(--bg); border: 1px solid var(--border); border-radius: 8px;
  }
  .causal-grid-labels-top {
    display: flex; align-items: center; margin-bottom: 3px;
  }
  .causal-grid-corner { width: 32px; height: 18px; }
  .causal-col-label {
    width: 34px; text-align: center; font-size: 9px;
    font-family: 'IBM Plex Mono', monospace; color: var(--accent); opacity: 0.6;
  }
  .causal-grid-row { display: flex; align-items: center; margin-bottom: 2px; }
  .causal-row-label {
    width: 32px; text-align: right; padding-right: 6px; font-size: 9px;
    font-family: 'IBM Plex Mono', monospace; color: var(--accent); opacity: 0.6;
  }
  .causal-cell {
    width: 34px; height: 28px; display: flex; align-items: center;
    justify-content: center; border-radius: 4px; margin: 0 0px;
  }
  .causal-ok { background: rgba(63,185,80,0.1); border: 1px solid rgba(63,185,80,0.15); }
  .causal-blocked { background: rgba(248,81,73,0.06); border: 1px solid rgba(248,81,73,0.1); }

  /* ‚îÄ‚îÄ Heatmap Legend & Notes ‚îÄ‚îÄ */
  .heatmap-legend {
    display: flex; flex-wrap: wrap; gap: 14px; align-items: center;
    margin: 12px 0 6px; padding: 8px 12px; border-radius: 6px;
    background: var(--bg); border: 1px solid var(--border);
  }
  .heatmap-legend-item {
    display: flex; align-items: center; gap: 6px; font-size: 11px;
    font-family: 'IBM Plex Mono', monospace; color: var(--text-dim);
  }
  .heatmap-legend-label { font-weight: 600; color: var(--text); }
  .heatmap-legend-dot {
    width: 14px; height: 14px; border-radius: 3px; display: inline-block;
    border: 1px solid rgba(255,255,255,0.05);
  }
  .heatmap-notes { display: flex; flex-direction: column; gap: 3px; margin-top: 6px; }
  .heatmap-note {
    display: flex; align-items: center; gap: 8px; font-size: 11.5px;
    font-family: 'IBM Plex Mono', monospace; color: var(--text-dim);
  }
  .heatmap-note-icon { color: var(--accent); opacity: 0.5; min-width: 16px; text-align: center; }

  /* ‚îÄ‚îÄ Autoregressive Demo ‚îÄ‚îÄ */
  .autoreg-demo {
    margin: 12px 0; padding: 14px; background: var(--bg);
    border: 1px solid var(--border); border-radius: 8px;
  }
  .autoreg-step {
    display: flex; align-items: center; gap: 8px; flex-wrap: wrap;
    padding: 8px 10px; border-radius: 6px; margin-bottom: 6px;
    background: rgba(255,255,255,0.015); border: 1px solid var(--border);
  }
  .autoreg-step-label {
    font-size: 10px; font-weight: 700; color: var(--text-dim);
    font-family: 'IBM Plex Mono', monospace; min-width: 44px;
  }
  .autoreg-tokens { display: flex; gap: 3px; }
  .autoreg-tok {
    display: inline-flex; align-items: center; justify-content: center;
    min-width: 28px; height: 26px; padding: 0 6px; border-radius: 4px;
    font-family: 'IBM Plex Mono', monospace; font-size: 12px; font-weight: 600;
  }
  .autoreg-tok.input {
    background: var(--accent-dim); color: var(--accent);
    border: 1px solid rgba(88,166,255,0.25);
  }
  .autoreg-tok.generated {
    background: var(--green-dim); color: var(--green);
    border: 1px solid rgba(63,185,80,0.25);
  }
  .autoreg-arrow-right { color: var(--text-dim); font-size: 14px; }
  .autoreg-model {
    padding: 3px 10px; border-radius: 4px; font-size: 11px; font-weight: 600;
    font-family: 'IBM Plex Mono', monospace; color: var(--orange);
    background: rgba(210,153,34,0.08); border: 1px solid rgba(210,153,34,0.2);
  }
  .autoreg-pipeline {
    display: flex; align-items: center; gap: 6px; margin-top: 10px;
    padding: 8px 12px; border-radius: 6px;
    background: rgba(188,140,255,0.04); border: 1px solid rgba(188,140,255,0.12);
    justify-content: center; flex-wrap: wrap;
  }
  .autoreg-pipe-step {
    font-size: 11px; font-family: 'IBM Plex Mono', monospace; font-weight: 600;
    color: var(--purple); padding: 2px 8px; border-radius: 3px;
    background: rgba(188,140,255,0.08); border: 1px solid rgba(188,140,255,0.15);
  }
  .autoreg-pipe-arr { color: var(--text-dim); font-size: 12px; }

  /* ‚îÄ‚îÄ KV-Cache Demo ‚îÄ‚îÄ */
  .kvcache-demo {
    margin: 12px 0; padding: 14px; background: var(--bg);
    border: 1px solid var(--border); border-radius: 8px;
  }
  .kvcache-step {
    padding: 10px 12px; border-radius: 6px; margin-bottom: 8px;
    background: rgba(255,255,255,0.015); border: 1px solid var(--border);
  }
  .kvcache-step-header {
    display: flex; align-items: center; gap: 10px; margin-bottom: 8px;
  }
  .kvcache-step-num {
    font-size: 11px; font-weight: 700; font-family: 'IBM Plex Mono', monospace;
    color: var(--accent); padding: 1px 8px; border-radius: 3px;
    background: rgba(88,166,255,0.1); border: 1px solid rgba(88,166,255,0.15);
  }
  .kvcache-step-desc {
    font-size: 12px; color: var(--text-dim); font-family: 'IBM Plex Mono', monospace;
  }
  .kvcache-row {
    display: flex; align-items: center; gap: 10px; margin-bottom: 5px;
  }
  .kvcache-input-label {
    font-size: 10px; font-weight: 600; color: var(--text-dim);
    font-family: 'IBM Plex Mono', monospace; min-width: 46px; text-align: right;
  }
  .kvcache-tokens { display: flex; gap: 3px; }
  .kvcache-cache-slots { display: flex; gap: 3px; flex-wrap: wrap; }
  .kvcache-slot {
    display: inline-block; padding: 3px 8px; border-radius: 4px;
    font-size: 11px; font-family: 'IBM Plex Mono', monospace; font-weight: 600;
  }
  .kvcache-slot.filled {
    background: rgba(57,210,192,0.1); color: var(--cyan);
    border: 1px solid rgba(57,210,192,0.2);
  }
  .kvcache-slot.cached {
    background: rgba(107,122,141,0.1); color: var(--text-dim);
    border: 1px dashed rgba(107,122,141,0.25);
  }
  .kvcache-slot.new-slot {
    box-shadow: 0 0 6px rgba(57,210,192,0.2);
  }
  .kvcache-attn-desc {
    font-size: 12px; color: var(--text); font-family: 'IBM Plex Mono', monospace;
  }
  .kvcache-attn-desc strong { color: var(--text-bright); }
  .kvcache-comparison {
    display: flex; gap: 10px; margin-top: 10px;
  }
  .kvcache-compare-item {
    flex: 1; padding: 10px 14px; border-radius: 6px; text-align: center;
    font-family: 'IBM Plex Mono', monospace;
  }
  .kvcache-compare-item.bad {
    background: rgba(248,81,73,0.06); border: 1px solid rgba(248,81,73,0.15);
  }
  .kvcache-compare-item.good {
    background: rgba(63,185,80,0.06); border: 1px solid rgba(63,185,80,0.15);
  }
  .kvcache-compare-label {
    font-size: 10px; color: var(--text-dim); text-transform: uppercase;
    letter-spacing: 1px; margin-bottom: 4px;
  }
  .kvcache-compare-val { font-size: 16px; font-weight: 700; margin-bottom: 2px; }
  .bad .kvcache-compare-val { color: var(--red); }
  .good .kvcache-compare-val { color: var(--green); }
  .kvcache-compare-desc { font-size: 11px; color: var(--text-dim); }

  /* ‚îÄ‚îÄ FLOPs Table ‚îÄ‚îÄ */
  .flops-table {
    margin: 10px 0; padding: 12px; background: var(--bg);
    border: 1px solid var(--border); border-radius: 8px;
    font-family: 'IBM Plex Mono', monospace;
  }
  .flops-header {
    display: flex; align-items: center; padding: 0 4px 8px;
    border-bottom: 1px solid var(--border); margin-bottom: 6px;
  }
  .flops-h-name { flex: 1; font-size: 10px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; }
  .flops-h-val { width: 100px; text-align: right; font-size: 10px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; }
  .flops-h-bar { flex: 1; text-align: right; font-size: 10px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; padding-left: 12px; }
  .flops-row {
    display: flex; align-items: center; padding: 4px 4px;
  }
  .flops-name { flex: 1; font-size: 12px; color: var(--text); }
  .flops-val { width: 100px; text-align: right; font-size: 12px; color: var(--text-bright); }
  .flops-bar-wrap { flex: 1; display: flex; align-items: center; gap: 6px; padding-left: 12px; }
  .flops-bar { height: 10px; border-radius: 3px; min-width: 2px; }
  .flops-pct { font-size: 10px; color: var(--text-dim); }
  .flops-divider { height: 1px; background: var(--border); margin: 6px 0; }
  .flops-divider.thick { height: 2px; background: var(--border-hi); }
  .flops-subtotal .flops-name, .flops-subtotal .flops-val { color: var(--text-dim); }
  .flops-total .flops-name { font-weight: 700; color: var(--text-bright); font-size: 13px; }
  .flops-total .flops-val { font-weight: 700; color: var(--cyan); font-size: 13px; }

  /* ‚îÄ‚îÄ Scaling Insight Cards ‚îÄ‚îÄ */
  .scaling-insight {
    margin-top: 14px; padding: 12px; background: var(--bg);
    border: 1px solid var(--border); border-radius: 8px;
  }
  .scaling-insight-title {
    font-size: 10px; text-transform: uppercase; letter-spacing: 1.5px;
    color: var(--text-dim); font-family: 'IBM Plex Mono', monospace;
    margin-bottom: 10px;
  }
  .scaling-cards { display: flex; gap: 8px; }
  .scaling-card {
    flex: 1; padding: 10px 12px; border-radius: 6px;
    background: rgba(255,255,255,0.015); border: 1px solid var(--border);
    text-align: center; font-family: 'IBM Plex Mono', monospace;
  }
  .scaling-card-head { font-size: 11px; font-weight: 700; margin-bottom: 4px; }
  .scaling-card-formula { font-size: 16px; font-weight: 700; color: var(--text-bright); margin-bottom: 4px; }
  .scaling-card-desc { font-size: 10px; color: var(--text-dim); line-height: 1.4; }

  @media (max-width: 600px) {
    .scaling-cards { flex-direction: column; }
    .kvcache-comparison { flex-direction: column; }
    .autoreg-step { font-size: 11px; }
  }
</style>
</head>
<body>
<div id="root"></div>
<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MATH ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function seededRng(seed) {
  let s = seed;
  return () => { s = (s * 1664525 + 1013904223) & 0xffffffff; return (s >>> 0) / 0xffffffff; };
}

const C = { V:64, D:32, H:4, KV:2, Dh:8, Ff:86, L:2, maxSeq:16, theta:10000, eps:1e-6 };

function randn(shape, scale, rng) {
  const sz = shape.reduce((a,b)=>a*b,1), d = new Float32Array(sz);
  for (let i=0;i<sz;i+=2) {
    const u1=rng()||1e-10, u2=rng(), r=Math.sqrt(-2*Math.log(u1));
    d[i]=r*Math.cos(2*Math.PI*u2)*scale;
    if(i+1<sz) d[i+1]=r*Math.sin(2*Math.PI*u2)*scale;
  }
  return {d,s:[...shape]};
}
function ones(shape) { return {d:new Float32Array(shape.reduce((a,b)=>a*b,1)).fill(1),s:[...shape]}; }
function zeros(shape) { return {d:new Float32Array(shape.reduce((a,b)=>a*b,1)),s:[...shape]}; }
function clone(t) { return {d:new Float32Array(t.d),s:[...t.s]}; }

function matmul2d(a,b) {
  const [M,K]=a.s, N=b.s[1], o=zeros([M,N]);
  for(let m=0;m<M;m++) for(let n=0;n<N;n++) {
    let v=0; for(let k=0;k<K;k++) v+=a.d[m*K+k]*b.d[k*N+n]; o.d[m*N+n]=v;
  }
  return o;
}
function matmul1x2d(a,b) {
  const K=a.s[0],N=b.s[1],o=zeros([N]);
  for(let n=0;n<N;n++){let v=0;for(let k=0;k<K;k++)v+=a.d[k]*b.d[k*N+n];o.d[n]=v;}
  return o;
}
function bmm(a,b) {
  const [B,M,K]=a.s, N=b.s[2], o=zeros([B,M,N]);
  for(let bi=0;bi<B;bi++) for(let m=0;m<M;m++) for(let n=0;n<N;n++) {
    let v=0; for(let k=0;k<K;k++) v+=a.d[bi*M*K+m*K+k]*b.d[bi*K*N+k*N+n];
    o.d[bi*M*N+m*N+n]=v;
  }
  return o;
}
function transpose3d(t) {
  const [B,M,N]=t.s, o=zeros([B,N,M]);
  for(let b=0;b<B;b++) for(let m=0;m<M;m++) for(let n=0;n<N;n++)
    o.d[b*N*M+n*M+m]=t.d[b*M*N+m*N+n];
  return o;
}
function perm012to102(t) {
  const [S,H,D]=t.s, o=zeros([H,S,D]);
  for(let s=0;s<S;s++) for(let h=0;h<H;h++) for(let d=0;d<D;d++)
    o.d[h*S*D+s*D+d]=t.d[s*H*D+h*D+d];
  return o;
}
function perm102to012(t) {
  const [H,S,D]=t.s, o=zeros([S,H,D]);
  for(let s=0;s<S;s++) for(let h=0;h<H;h++) for(let d=0;d<D;d++)
    o.d[s*H*D+h*D+d]=t.d[h*S*D+s*D+d];
  return o;
}
function reshape(t,ns) { return {d:t.d,s:[...ns]}; }
function sliceRows(t,rows) {
  const c=t.s[1],o=zeros([rows.length,c]);
  for(let i=0;i<rows.length;i++){const src=rows[i]*c;for(let j=0;j<c;j++)o.d[i*c+j]=t.d[src+j];}
  return o;
}
function sliceRow(t,r) { const c=t.s[t.s.length-1]; return {d:t.d.slice(r*c,r*c+c),s:[c]}; }
function add(a,b) { const o={d:new Float32Array(a.d.length),s:[...a.s]}; for(let i=0;i<a.d.length;i++)o.d[i]=a.d[i]+b.d[i]; return o; }
function mul(a,b) { const o={d:new Float32Array(a.d.length),s:[...a.s]}; for(let i=0;i<a.d.length;i++)o.d[i]=a.d[i]*b.d[i]; return o; }
function norm(t) { let s=0; for(let i=0;i<t.d.length;i++)s+=t.d[i]*t.d[i]; return Math.sqrt(s); }

function rmsnorm(x,w) {
  const [S,D]=x.s, o=zeros(x.s);
  for(let s=0;s<S;s++) {
    let sq=0; for(let d=0;d<D;d++){const v=x.d[s*D+d];sq+=v*v;}
    const rms=Math.sqrt(sq/D+C.eps);
    for(let d=0;d<D;d++) o.d[s*D+d]=(x.d[s*D+d]/rms)*w.d[d];
  }
  return o;
}

function computeRope() {
  const hd=C.Dh/2, fr=new Float32Array(hd);
  for(let i=0;i<hd;i++) fr[i]=1/Math.pow(C.theta,2*i/C.Dh);
  const cos=zeros([C.maxSeq,hd]),sin=zeros([C.maxSeq,hd]);
  for(let t=0;t<C.maxSeq;t++) for(let i=0;i<hd;i++) {
    const a=t*fr[i]; cos.d[t*hd+i]=Math.cos(a); sin.d[t*hd+i]=Math.sin(a);
  }
  return {cos,sin,fr};
}

function applyRope(qk,cos,sin,sp) {
  sp=sp||0;
  const [S,nH,dH]=qk.s, hd=dH/2, o=zeros(qk.s);
  for(let s=0;s<S;s++){const p=sp+s;
    for(let h=0;h<nH;h++) for(let i=0;i<hd;i++){
      const cv=cos.d[p*hd+i],sv=sin.d[p*hd+i];
      const ev=qk.d[s*nH*dH+h*dH+i], od=qk.d[s*nH*dH+h*dH+hd+i];
      o.d[s*nH*dH+h*dH+i]=ev*cv-od*sv;
      o.d[s*nH*dH+h*dH+hd+i]=ev*sv+od*cv;
    }
  }
  return o;
}

function expandKV(t,nRep) {
  if(nRep===1)return t;
  const [S,nKV,D]=t.s, o=zeros([S,nKV*nRep,D]);
  for(let s=0;s<S;s++) for(let kv=0;kv<nKV;kv++) for(let r=0;r<nRep;r++)
    for(let d=0;d<D;d++) o.d[s*nKV*nRep*D+(kv*nRep+r)*D+d]=t.d[s*nKV*D+kv*D+d];
  return o;
}

function silu(x) {
  const o={d:new Float32Array(x.d.length),s:[...x.s]};
  for(let i=0;i<x.d.length;i++){const v=x.d[i];o.d[i]=v/(1+Math.exp(-v));}
  return o;
}

function softmaxRow(d,off,len) {
  let mx=-Infinity; for(let i=0;i<len;i++)mx=Math.max(mx,d[off+i]);
  let sm=0; for(let i=0;i<len;i++){d[off+i]=Math.exp(d[off+i]-mx);sm+=d[off+i];}
  for(let i=0;i<len;i++)d[off+i]/=sm;
}
function softmax1D(logits) {
  const o=new Float32Array(logits.length);
  let mx=-Infinity; for(let i=0;i<logits.length;i++)mx=Math.max(mx,logits[i]);
  let sm=0; for(let i=0;i<logits.length;i++){o[i]=Math.exp(logits[i]-mx);sm+=o[i];}
  for(let i=0;i<logits.length;i++)o[i]/=sm;
  return o;
}

function attention(q,k,v) {
  const S=q.s[0],nH=q.s[1];
  const qt=perm012to102(q),kt=perm012to102(k),vt=perm012to102(v);
  const sc=bmm(qt,transpose3d(kt)), scale=Math.sqrt(C.Dh);
  for(let i=0;i<sc.d.length;i++)sc.d[i]/=scale;
  for(let h=0;h<nH;h++) for(let i=0;i<S;i++) for(let j=i+1;j<S;j++)
    sc.d[h*S*S+i*S+j]=-1e9;
  for(let h=0;h<nH;h++) for(let i=0;i<S;i++) softmaxRow(sc.d,h*S*S+i*S,S);
  return {output:perm102to012(bmm(sc,vt)),weights:sc};
}

function initParams(rng) {
  const p={}, w=(sh)=>randn(sh,0.02,rng);
  p.tokEmb=w([C.V,C.D]);
  for(let l=0;l<C.L;l++){
    const f=`l${l}_`;
    p[f+'an']=ones([C.D]); p[f+'wq']=w([C.D,C.H*C.Dh]); p[f+'wk']=w([C.D,C.KV*C.Dh]);
    p[f+'wv']=w([C.D,C.KV*C.Dh]); p[f+'wo']=w([C.H*C.Dh,C.D]); p[f+'fn']=ones([C.D]);
    p[f+'wg']=w([C.D,C.Ff]); p[f+'wu']=w([C.D,C.Ff]); p[f+'wd']=w([C.Ff,C.D]);
  }
  p.finalNorm=ones([C.D]); p.lmHead=w([C.D,C.V]);
  return p;
}

function forwardBlock(x,l,p,rope) {
  const nRep=C.H/C.KV, S=x.s[0], f=`l${l}_`;
  const xn=rmsnorm(x,p[f+'an']);
  let q=reshape(matmul2d(xn,p[f+'wq']),[S,C.H,C.Dh]);
  let k=reshape(matmul2d(xn,p[f+'wk']),[S,C.KV,C.Dh]);
  let v=reshape(matmul2d(xn,p[f+'wv']),[S,C.KV,C.Dh]);
  q=applyRope(q,rope.cos,rope.sin); k=applyRope(k,rope.cos,rope.sin);
  const kE=expandKV(k,nRep),vE=expandKV(v,nRep);
  const {output:aO,weights:aW}=attention(q,kE,vE);
  let h=add(x,matmul2d(reshape(aO,[S,C.H*C.Dh]),p[f+'wo']));
  const hn=rmsnorm(h,p[f+'fn']);
  const gate=silu(matmul2d(hn,p[f+'wg'])),up=matmul2d(hn,p[f+'wu']);
  h=add(h,matmul2d(mul(gate,up),p[f+'wd']));
  return {h,aW,q,k:kE,v:vE};
}

function fullForward(ids,p,rope) {
  let h=sliceRows(p.tokEmb,ids);
  const layers=[];
  for(let l=0;l<C.L;l++){const r=forwardBlock(h,l,p,rope);layers.push(r);h=r.h;}
  const hN=rmsnorm(h,p.finalNorm), last=sliceRow(hN,ids.length-1);
  const logits=matmul1x2d(last,p.lmHead);
  return {logits:logits.d,layers,hN};
}

function sampleToken(logits,temp,topK,rng) {
  const V=logits.length, sc=new Float32Array(V);
  for(let i=0;i<V;i++)sc[i]=logits[i]/temp;
  const idx=Array.from({length:V},(_,i)=>i).sort((a,b)=>sc[b]-sc[a]);
  const fil=new Float32Array(V).fill(-1e9);
  for(let i=0;i<topK;i++)fil[idx[i]]=sc[idx[i]];
  const pr=softmax1D(fil);
  let r=rng(),cum=0;
  for(let i=0;i<V;i++){cum+=pr[i];if(r<cum)return{id:i,pr};}
  return{id:V-1,pr};
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INIT MODEL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const params = initParams(seededRng(42));
const rope = computeRope();
const INPUT_IDS = [12, 5, 41, 33, 7];
const SEQ = INPUT_IDS.length;
const result = fullForward(INPUT_IDS, params, rope);
const embedded = sliceRows(params.tokEmb, INPUT_IDS);

let totalP = 0;
for (const k in params) totalP += params[k].d.length;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DOM RENDERING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function fmtArr(data, n, dec) {
  n=n||8; dec=dec||4;
  const items=Array.from(data).slice(0,n).map(v=>v.toFixed(dec));
  if(data.length>n) items.push('...+'+(data.length-n));
  return '['+items.join(', ')+']';
}

function createSection(id, title, emoji, content, open) {
  const sec = document.createElement('div');
  sec.className = 'section';
  const hdr = document.createElement('button');
  hdr.className = 'section-header' + (open ? ' open' : '');
  hdr.innerHTML = `<span class="emoji">${emoji}</span><span class="title">${title}</span><span class="arrow">‚ñ∂</span>`;
  const body = document.createElement('div');
  body.className = 'section-body';
  body.style.display = open ? 'block' : 'none';
  if (typeof content === 'string') body.innerHTML = content;
  else body.appendChild(content);
  hdr.onclick = () => {
    const isOpen = body.style.display !== 'none';
    body.style.display = isOpen ? 'none' : 'block';
    hdr.className = 'section-header' + (isOpen ? '' : ' open');
  };
  sec.appendChild(hdr);
  sec.appendChild(body);
  return sec;
}

function buildHeatmap(weights, seqLen, headIdx) {
  const cellSz = Math.min(38, 210/seqLen);
  const wrap = document.createElement('div');
  wrap.style.cssText = 'display:inline-block;margin:4px 12px 4px 0;';
  wrap.innerHTML = `<div class="heatmap-label">Head ${headIdx}</div>`;
  const grid = document.createElement('div');
  grid.className = 'heatmap-grid';
  grid.style.gridTemplateColumns = `repeat(${seqLen}, ${cellSz}px)`;
  const off = headIdx * seqLen * seqLen;
  for (let r = 0; r < seqLen; r++) for (let c = 0; c < seqLen; c++) {
    const v = weights.d[off + r*seqLen + c];
    const intensity = Math.pow(v, 0.5);
    const cell = document.createElement('div');
    cell.className = 'heatmap-cell';
    cell.style.cssText = `width:${cellSz}px;height:${cellSz}px;font-size:${cellSz>28?8:0}px;`;
    cell.style.background = c > r ? 'var(--surface)' : `rgba(88,166,255,${intensity*0.9+0.05})`;
    cell.style.color = intensity > 0.5 ? '#000' : 'var(--text-dim)';
    cell.title = `pos ${r} ‚Üí pos ${c}: ${v.toFixed(4)}`;
    if (cellSz > 28) cell.textContent = v.toFixed(2);
    grid.appendChild(cell);
  }
  wrap.appendChild(grid);
  return wrap;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// BUILD PAGE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const root = document.getElementById('root');

// Header
root.innerHTML = `
<div class="header-label">Interactive Notebook</div>
<h1>The Transformer Decoder<br><span class="sub">Every Computation, From Scratch</span></h1>
<p class="intro">A complete walkthrough of every operation inside a GPT-style autoregressive transformer decoder. All computations run live in your browser with no frameworks ‚Äî just typed arrays and arithmetic. Expand each section to inspect tensor values at every stage.</p>
<div class="tags">
  <span class="tag">vocab=64</span><span class="tag">d_model=32</span><span class="tag">heads=4</span>
  <span class="tag cyan">kv_heads=2 (GQA)</span><span class="tag">d_ff=86</span><span class="tag">layers=2</span>
  <span class="tag orange">${totalP.toLocaleString()} params</span>
</div>
`;

// 0 ‚Äî Architecture
(() => {
  const archFrag = document.createElement('div');
  archFrag.innerHTML = `
<div class="prose" style="margin-bottom:16px">The complete data flow from token IDs to next-token prediction. Each box is a computation you can inspect in the sections below.</div>
<div class="arch-diagram">
  <div class="arch-flow">

    <div class="arch-node arch-input">
      <div class="arch-node-label">Input</div>
      <div class="arch-node-title">Token IDs</div>
      <div class="arch-node-detail">[12, 5, 41, 33, 7]</div>
    </div>
    <div class="arch-arrow"><svg width="20" height="28" viewBox="0 0 20 28"><path d="M10 0 L10 20 M4 15 L10 22 L16 15" stroke="var(--text-dim)" stroke-width="1.5" fill="none"/></svg></div>

    <div class="arch-node arch-embed">
      <div class="arch-node-icon">&#167;1</div>
      <div class="arch-node-title">Token Embedding</div>
      <div class="arch-node-detail">Lookup table: E &#8712; &#8477;<sup>64&#215;32</sup></div>
      <div class="arch-node-shape">(5, 32)</div>
    </div>
    <div class="arch-arrow"><svg width="20" height="28" viewBox="0 0 20 28"><path d="M10 0 L10 20 M4 15 L10 22 L16 15" stroke="var(--text-dim)" stroke-width="1.5" fill="none"/></svg></div>

    <div class="arch-layer-wrap">
      <div class="arch-layer-badge">&#215; 2 layers</div>
      <div class="arch-layer">

        <div class="arch-sublayer">
          <div class="arch-sublayer-header">
            <span class="arch-sublayer-tag attn-tag">Attention Sub-layer</span>
            <span class="arch-residual-badge">+ residual</span>
          </div>
          <div class="arch-step-grid">
            <div class="arch-step"><span class="arch-step-ref">&#167;3</span><span class="arch-step-name">RMSNorm</span></div>
            <div class="arch-step"><span class="arch-step-ref">&#167;4</span><span class="arch-step-name">Q, K, V Projections</span><span class="arch-step-info">Q&#8594;(5,4,8) &ensp;K&#8594;(5,2,8) &ensp;V&#8594;(5,2,8)</span></div>
            <div class="arch-step"><span class="arch-step-ref">&#167;2</span><span class="arch-step-name">RoPE</span><span class="arch-step-info">Rotate Q, K (not V)</span></div>
            <div class="arch-step"><span class="arch-step-ref">&#167;4</span><span class="arch-step-name">GQA Expand</span><span class="arch-step-info">K, V: 2 heads &#8594; 4 heads</span></div>
            <div class="arch-step"><span class="arch-step-ref">&#167;5</span><span class="arch-step-name">Scaled Dot-Product Attention</span><span class="arch-step-info">QK&#7488;/&#8730;8 + causal mask &#8594; softmax &#8594; &#215;V</span></div>
            <div class="arch-step"><span class="arch-step-ref">&#167;5</span><span class="arch-step-name">Output Projection</span><span class="arch-step-info">Concat heads &#8594; W_o &#8594; (5, 32)</span></div>
          </div>
        </div>

        <div class="arch-inner-arrow"><svg width="20" height="18" viewBox="0 0 20 18"><path d="M10 0 L10 12 M5 8 L10 14 L15 8" stroke="var(--border-hi)" stroke-width="1.2" fill="none"/></svg></div>

        <div class="arch-sublayer">
          <div class="arch-sublayer-header">
            <span class="arch-sublayer-tag ffn-tag">FFN Sub-layer</span>
            <span class="arch-residual-badge">+ residual</span>
          </div>
          <div class="arch-step-grid">
            <div class="arch-step"><span class="arch-step-ref">&#167;3</span><span class="arch-step-name">RMSNorm</span></div>
            <div class="arch-step"><span class="arch-step-ref">&#167;6</span><span class="arch-step-name">SwiGLU FFN</span><span class="arch-step-info">SiLU(x&#183;W_gate) &#8857; x&#183;W_up &#8594; W_down</span></div>
          </div>
        </div>

      </div>
    </div>

    <div class="arch-arrow"><svg width="20" height="28" viewBox="0 0 20 28"><path d="M10 0 L10 20 M4 15 L10 22 L16 15" stroke="var(--text-dim)" stroke-width="1.5" fill="none"/></svg></div>

    <div class="arch-node arch-output-stack">
      <div class="arch-output-row">
        <div class="arch-mini-node norm-node"><span class="arch-step-ref">&#167;3</span> Final RMSNorm</div>
        <div class="arch-output-arr">&#8594;</div>
        <div class="arch-mini-node head-node"><span class="arch-step-ref">&#167;8</span> LM Head<div class="arch-node-shape" style="margin:2px 0 0">(32,) &#8594; (64,)</div></div>
        <div class="arch-output-arr">&#8594;</div>
        <div class="arch-mini-node sample-node"><span class="arch-step-ref">&#167;9</span> Sample<div class="arch-node-shape" style="margin:2px 0 0">temp / top-k</div></div>
      </div>
    </div>
    <div class="arch-arrow"><svg width="20" height="28" viewBox="0 0 20 28"><path d="M10 0 L10 20 M4 15 L10 22 L16 15" stroke="var(--text-dim)" stroke-width="1.5" fill="none"/></svg></div>

    <div class="arch-node arch-result">
      <div class="arch-node-label">Output</div>
      <div class="arch-node-title">Next Token ID</div>
    </div>

  </div>
</div>`;
  root.appendChild(createSection('arch', '0 &#8212; Architecture Overview', '&#127959;&#65039;', archFrag, true));
})();

// 1 ‚Äî Embedding
root.appendChild(createSection('emb', '1 ‚Äî Token Embedding', 'üìñ',
`<div class="prose">Convert integer token IDs to dense vectors via <strong>table lookup</strong>. Row <span class="tag">i</span> of the embedding matrix becomes the vector for token <span class="tag">i</span>.</div>
<div class="math-block">x_t = E[token_t] &nbsp;&nbsp; ‚àà ‚Ñù^(d_model) &nbsp;&nbsp; where E ‚àà ‚Ñù^(V √ó d_model)</div>
<div class="output">Input token IDs: [${INPUT_IDS.join(', ')}]
Embedding matrix: shape=(${C.V}, ${C.D})
After lookup:     shape=(${SEQ}, ${C.D})

Embedding for token ${INPUT_IDS[0]}:
  ${fmtArr(embedded.d.slice(0, C.D), 10)}</div>`));

// 2 ‚Äî RoPE
root.appendChild(createSection('rope', '2 ‚Äî Rotary Positional Embeddings (RoPE)', 'üåÄ',
`<div class="prose">RoPE encodes position by <strong>rotating</strong> pairs of dimensions in Q and K. For dimension pair (2i, 2i+1) at position t, a 2D rotation is applied with angle t¬∑Œ∏_i.</div>
<div class="math-block">Œ∏_i = 1 / (10000^(2i / d_head)) &nbsp;&nbsp;&nbsp; [q'_even, q'_odd] = Rot(t¬∑Œ∏_i) ¬∑ [q_even, q_odd]</div>
<div class="prose">The dot product Q¬∑K then naturally depends only on <strong>relative</strong> position ‚Äî no learnable parameters needed. This generalizes better to longer sequences than trained position embeddings.</div>
<div class="output">Dimension pairs: ${C.Dh/2}
Frequencies (Œ∏_i): ${fmtArr(rope.fr, 4, 6)}

Cos table at position 0: ${fmtArr(rope.cos.d.slice(0,4), 4)}
Cos table at position 1: ${fmtArr(rope.cos.d.slice(4,8), 4)}
Cos table at position 3: ${fmtArr(rope.cos.d.slice(12,16), 4)}

Note: position 0 ‚Üí no rotation (cos=1), increasing positions ‚Üí more rotation</div>`));

// 3 ‚Äî RMSNorm
(() => {
  const xn = rmsnorm(embedded, params.l0_an);
  const rmsB = Math.sqrt(Array.from(embedded.d.slice(0,C.D)).reduce((s,v)=>s+v*v,0)/C.D);
  const rmsA = Math.sqrt(Array.from(xn.d.slice(0,C.D)).reduce((s,v)=>s+v*v,0)/C.D);
  root.appendChild(createSection('rmsnorm', '3 ‚Äî RMSNorm (Root Mean Square Normalization)', 'üìè',
`<div class="prose">Modern transformers use <strong>RMSNorm</strong> instead of LayerNorm. Simpler: no mean subtraction, no bias ‚Äî just divide by root-mean-square and scale by a learnable Œ≥.</div>
<div class="math-block">RMSNorm(x) = (x / RMS(x)) ¬∑ Œ≥ &nbsp;&nbsp; where RMS(x) = ‚àö(mean(x¬≤) + Œµ)</div>
<div class="output">Before RMSNorm (token 0):
  RMS = ${rmsB.toFixed(6)}
  values: ${fmtArr(embedded.d.slice(0, C.D), 8)}

After RMSNorm (token 0):
  RMS = ${rmsA.toFixed(6)}  (‚âà 1.0 since Œ≥ = 1)
  values: ${fmtArr(xn.d.slice(0, C.D), 8)}</div>`));
})();

// 4 ‚Äî QKV + GQA
root.appendChild(createSection('qkv', '4 ‚Äî Q, K, V Projections + GQA', 'üîë',
`<div class="prose">Three linear projections create Query, Key, and Value tensors. In <strong>Grouped-Query Attention</strong>, K and V have fewer heads (2) than Q (4). Each KV head serves 2 query heads ‚Äî halving KV-cache memory.</div>
<div class="math-block">Q = x¬∑W_q ‚àà ‚Ñù^(seq, 4, 8) &nbsp;|&nbsp; K = x¬∑W_k ‚àà ‚Ñù^(seq, 2, 8) &nbsp;|&nbsp; V = x¬∑W_v ‚àà ‚Ñù^(seq, 2, 8)</div>
<div class="output">Projection weights:
  W_q: (${C.D}, ${C.H*C.Dh})    ‚Üí Q has ${C.H} heads
  W_k: (${C.D}, ${C.KV*C.Dh})   ‚Üí K has ${C.KV} heads
  W_v: (${C.D}, ${C.KV*C.Dh})   ‚Üí V has ${C.KV} heads

GQA expansion: repeat each KV head ${C.H/C.KV}√ó
  K: (${SEQ}, 2, 8) ‚Üí (${SEQ}, 4, 8)
  V: (${SEQ}, 2, 8) ‚Üí (${SEQ}, 4, 8)

  KV head 0 serves query heads [0, 1]
  KV head 1 serves query heads [2, 3]

Multi-Head Attention (MHA):  4 KV heads for 4 Q heads  = 1√ó memory
Multi-Query Attention (MQA): 1 KV head  for 4 Q heads  = 0.25√ó memory
Grouped-Query (GQA):         2 KV heads for 4 Q heads  = 0.5√ó memory  ‚Üê our config</div>`));

// 5 ‚Äî Attention (with heatmaps)
(() => {
  const frag = document.createElement('div');
  frag.innerHTML = `
<div class="prose">The core computation: each position queries all previous positions. The <strong>causal mask</strong> prevents attending to the future.</div>
<div class="math-block">Attention(Q, K, V) = softmax(QK^T / ‚àöd_head + CausalMask) ¬∑ V</div>
<div class="prose"><strong>Causal mask</strong> &#8212; position i can only attend to positions 0..i:</div>
<div class="causal-grid-wrap">
  <div class="causal-grid-labels-top">
    <div class="causal-grid-corner"></div>
    ${Array.from({length:SEQ},(_,j)=>'<div class="causal-col-label">K'+j+'</div>').join('')}
  </div>
  ${Array.from({length:SEQ},(_,i)=>
    '<div class="causal-grid-row"><div class="causal-row-label">Q'+i+'</div>'
    +Array.from({length:SEQ},(_,j)=>
      j<=i
        ? '<div class="causal-cell causal-ok" title="Q'+i+' attends to K'+j+'"><svg width="14" height="14" viewBox="0 0 14 14"><path d="M3 7 L6 10 L11 4" stroke="var(--green)" stroke-width="1.8" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg></div>'
        : '<div class="causal-cell causal-blocked" title="Q'+i+' cannot see K'+j+' (future)"><svg width="14" height="14" viewBox="0 0 14 14"><path d="M4 4 L10 10 M10 4 L4 10" stroke="var(--red)" stroke-width="1.5" fill="none" stroke-linecap="round"/></svg></div>'
    ).join('')+'</div>'
  ).join('')}
</div>
<div class="prose" style="margin-top:16px"><strong>Attention weights</strong> after softmax &#8212; brighter = higher weight:</div>
<div class="prose" style="margin-top:10px;font-size:12px;color:var(--text-dim)">Layer 0:</div>
<div class="heatmap-wrap" id="hm-layer0"></div>
<div class="prose" style="margin-top:10px;font-size:12px;color:var(--text-dim)">Layer 1 (deeper, more refined patterns):</div>
<div class="heatmap-wrap" id="hm-layer1"></div>
<div class="heatmap-legend">
  <div class="heatmap-legend-item"><span class="heatmap-legend-label">Reading the heatmaps:</span></div>
  <div class="heatmap-legend-item"><span class="heatmap-legend-dot" style="background:var(--accent);opacity:0.3"></span> Low attention</div>
  <div class="heatmap-legend-item"><span class="heatmap-legend-dot" style="background:var(--accent)"></span> High attention</div>
  <div class="heatmap-legend-item"><span class="heatmap-legend-dot" style="background:var(--surface)"></span> Masked (future)</div>
</div>
<div class="heatmap-notes">
  <div class="heatmap-note"><span class="heatmap-note-icon">&#8594;</span> Row = query position, Column = key position</div>
  <div class="heatmap-note"><span class="heatmap-note-icon">&#8721;</span> Each row sums to 1.0 (softmax normalization)</div>
  <div class="heatmap-note"><span class="heatmap-note-icon">&#9632;</span> Position 0 always attends 100% to itself (only option)</div>
</div>`;
  const sec = createSection('attn', '5 ‚Äî Scaled Dot-Product Attention + Causal Mask', 'üëÅÔ∏è', frag, true);
  root.appendChild(sec);
  // Add heatmaps after DOM insertion
  setTimeout(() => {
    const hm0 = sec.querySelector('#hm-layer0');
    const hm1 = sec.querySelector('#hm-layer1');
    if (hm0) for (let h=0;h<C.H;h++) hm0.appendChild(buildHeatmap(result.layers[0].aW, SEQ, h));
    if (hm1) for (let h=0;h<C.H;h++) hm1.appendChild(buildHeatmap(result.layers[1].aW, SEQ, h));
  }, 0);
})();

// 6 ‚Äî SwiGLU FFN
root.appendChild(createSection('ffn', '6 ‚Äî SwiGLU Feed-Forward Network', '‚ö°',
`<div class="prose">After attention, each position passes through a <strong>gated feed-forward network</strong>. SwiGLU uses a learned gate to control which features are activated:</div>
<div class="math-block">FFN(x) = (SiLU(x¬∑W_gate) ‚äô x¬∑W_up) ¬∑ W_down</div>
<div class="prose"><span class="tag">SiLU(x) = x ¬∑ œÉ(x)</span> is a smooth, non-monotonic activation. Unlike ReLU, it allows small negative values and has no hard cutoff at zero.</div>
<div class="output">SiLU activation values:
  SiLU(-2.0) = ${(-2/(1+Math.exp(2))).toFixed(4)}   (small negative!)
  SiLU(-1.0) = ${(-1/(1+Math.exp(1))).toFixed(4)}
  SiLU( 0.0) = ${(0).toFixed(4)}
  SiLU( 1.0) = ${(1/(1+Math.exp(-1))).toFixed(4)}
  SiLU( 2.0) = ${(2/(1+Math.exp(-2))).toFixed(4)}

Weight shapes:
  W_gate: (${C.D}, ${C.Ff})   ‚Äî gate projection
  W_up:   (${C.D}, ${C.Ff})   ‚Äî up projection
  W_down: (${C.Ff}, ${C.D})   ‚Äî down projection

  3 matrices instead of 2 ‚Üí d_ff ‚âà (8/3)¬∑d_model to match param count
  Standard FFN: 2 √ó d √ó 4d = 8d¬≤
  SwiGLU FFN:   3 √ó d √ó (8/3)d = 8d¬≤  (same total params)</div>`));

// 7 ‚Äî Full forward
root.appendChild(createSection('layers', '7 ‚Äî Full Forward Pass (Both Layers)', 'üîÑ',
`<div class="prose">Each layer applies: <span class="tag">RMSNorm ‚Üí GQA Attention ‚Üí +Residual ‚Üí RMSNorm ‚Üí SwiGLU ‚Üí +Residual</span></div>
<div class="output">${result.layers.map((layer,i) =>
`Layer ${i}:
  Output norm: ${norm(layer.h).toFixed(4)}
  Hidden[0, :8]: ${fmtArr(layer.h.d.slice(0,8), 8)}`).join('\n\n')}

After all layers:
  Final RMSNorm applied
  Last token hidden state ‚Üí LM Head projection ‚Üí logits</div>`));

// 8 ‚Äî LM Head + Logits
(() => {
  const logits = result.logits;
  const indices = Array.from({length:C.V},(_,i)=>i).sort((a,b)=>logits[b]-logits[a]);
  const probs = softmax1D(logits);
  const barHtml = indices.slice(0,20).map(id =>
    `<div class="bar-row"><span class="bar-label">${id}</span><div class="bar-fill" style="width:${Math.max(probs[id]*600,1)}px"></div><span class="bar-value">${(probs[id]*100).toFixed(1)}%</span></div>`
  ).join('');

  root.appendChild(createSection('logits', '8 ‚Äî LM Head: Logits over Vocabulary', 'üéØ',
`<div class="prose">The last token's normalized hidden state is projected to a <span class="tag">vocab_size=64</span> logit vector. Each value is the raw score for that token being "next."</div>
<div class="math-block">logits = RMSNorm(h_last) ¬∑ W_head &nbsp;&nbsp; ‚àà ‚Ñù^(V)</div>
<div class="output">Logits shape: (${C.V},)
Range: [${Math.min(...logits).toFixed(4)}, ${Math.max(...logits).toFixed(4)}]

Top 10 next-token candidates:
${indices.slice(0,10).map((id,rank) =>
`  #${(rank+1).toString().padStart(2)}  token=${String(id).padStart(2)} | logit=${logits[id].toFixed(4).padStart(8)} | prob=${(probs[id]*100).toFixed(2).padStart(6)}%`
).join('\n')}</div>
<div class="prose" style="margin-top:8px">Probability distribution (top 20):</div>
<div style="margin:8px 0;max-height:280px;overflow-y:auto">${barHtml}</div>`, true));
})();

// 9 ‚Äî Sampling
(() => {
  const logits = result.logits;
  const rawProbs = softmax1D(logits);
  const scaled = Array.from(logits).map(v=>v/0.8);
  const scaledProbs = softmax1D(scaled);
  const indices = Array.from({length:C.V},(_,i)=>i).sort((a,b)=>logits[b]-logits[a]);

  root.appendChild(createSection('sampling', '9 ‚Äî Sampling: Temperature, Top-k, Softmax', 'üé≤',
`<div class="prose">Raw logits are transformed into a probability distribution for sampling. <strong>Temperature</strong> controls sharpness, <strong>top-k</strong> truncates to the k most likely tokens.</div>
<div class="math-block">p_i = exp(z_i / T) / Œ£_j exp(z_j / T) &nbsp;&nbsp; (after top-k filtering)</div>
<div class="output">Temperature=0.8 (sharpens distribution ‚Äî lower T = more deterministic):
${indices.slice(0,5).map(id =>
`  token ${String(id).padStart(2)}: prob ${(rawProbs[id]*100).toFixed(2)}% ‚Üí ${(scaledProbs[id]*100).toFixed(2)}%`
).join('\n')}

Top-k=10: keep only 10 highest-prob tokens, set rest to -‚àû
  ${C.V} tokens ‚Üí 10 candidates

Top-p=0.9 (nucleus): keep smallest set with cumulative prob ‚â• 90%
  Adapts k dynamically ‚Äî fewer candidates when model is confident

Pipeline: logits ‚Üí √∑temperature ‚Üí top-k filter ‚Üí top-p filter ‚Üí softmax ‚Üí sample</div>`));
})();

// 10 ‚Äî Generation
(() => {
  const frag = document.createElement('div');
  frag.innerHTML = `
<div class="prose">Feed the model its own output, one token at a time. Each step runs the <strong>full forward pass</strong> on the growing sequence. (A production system uses KV-cache to avoid recomputing past tokens.)</div>
<div class="autoreg-demo">
  <div class="autoreg-step">
    <div class="autoreg-step-label">Step 1</div>
    <div class="autoreg-tokens">
      <span class="autoreg-tok input">12</span><span class="autoreg-tok input">5</span><span class="autoreg-tok input">41</span><span class="autoreg-tok input">33</span><span class="autoreg-tok input">7</span>
    </div>
    <div class="autoreg-arrow-right">&#8594;</div>
    <div class="autoreg-model">model()</div>
    <div class="autoreg-arrow-right">&#8594;</div>
    <div class="autoreg-tok generated">?</div>
  </div>
  <div class="autoreg-step">
    <div class="autoreg-step-label">Step 2</div>
    <div class="autoreg-tokens">
      <span class="autoreg-tok input">12</span><span class="autoreg-tok input">5</span><span class="autoreg-tok input">41</span><span class="autoreg-tok input">33</span><span class="autoreg-tok input">7</span><span class="autoreg-tok generated">?</span>
    </div>
    <div class="autoreg-arrow-right">&#8594;</div>
    <div class="autoreg-model">model()</div>
    <div class="autoreg-arrow-right">&#8594;</div>
    <div class="autoreg-tok generated">?</div>
  </div>
  <div class="autoreg-step">
    <div class="autoreg-step-label">Step 3</div>
    <div class="autoreg-tokens">
      <span class="autoreg-tok input">12</span><span class="autoreg-tok input">5</span><span class="autoreg-tok input">41</span><span class="autoreg-tok input">33</span><span class="autoreg-tok input">7</span><span class="autoreg-tok generated">?</span><span class="autoreg-tok generated">?</span>
    </div>
    <div class="autoreg-arrow-right">&#8594;</div>
    <div class="autoreg-model">model()</div>
    <div class="autoreg-arrow-right">&#8594;</div>
    <div class="autoreg-tok generated">?</div>
  </div>
  <div class="autoreg-pipeline">
    <span class="autoreg-pipe-step">embed</span>
    <span class="autoreg-pipe-arr">&#8594;</span>
    <span class="autoreg-pipe-step">N layers</span>
    <span class="autoreg-pipe-arr">&#8594;</span>
    <span class="autoreg-pipe-step">norm</span>
    <span class="autoreg-pipe-arr">&#8594;</span>
    <span class="autoreg-pipe-step">LM head</span>
    <span class="autoreg-pipe-arr">&#8594;</span>
    <span class="autoreg-pipe-step">sample</span>
  </div>
</div>
<button class="gen-btn" id="gen-btn">‚ñ∂ Generate 8 Tokens</button>
<div id="gen-output"></div>`;
  root.appendChild(createSection('generate', '10 ‚Äî Autoregressive Generation', 'üöÄ', frag, true));

  document.getElementById('gen-btn').onclick = () => {
    const gr = seededRng(123);
    const seq = [...INPUT_IDS];
    const steps = [];
    for (let step=0;step<8;step++) {
      const r = fullForward(seq, params, rope);
      const {id,pr} = sampleToken(r.logits, 0.8, 10, gr);
      const topIds = Array.from({length:C.V},(_,i)=>i).sort((a,b)=>r.logits[b]-r.logits[a]).slice(0,5);
      steps.push({chosen:id, prob:pr[id], topIds, topProbs:topIds.map(i=>pr[i])});
      seq.push(id);
    }
    const out = document.getElementById('gen-output');
    out.innerHTML = `
<div class="output">Starting: [${INPUT_IDS.join(', ')}]
Generating 8 tokens (temperature=0.8, top_k=10)...

${steps.map((s,i) =>
`Step ${i+1}: chose token ${String(s.chosen).padStart(2)} (p=${(s.prob*100).toFixed(1)}%) | top: ${s.topIds.slice(0,3).map((id,j)=>`${id}=${(s.topProbs[j]*100).toFixed(1)}%`).join(', ')}`
).join('\n')}

Final: [${seq.join(', ')}]</div>
<div class="prose" style="margin-top:8px">Sequence tokens (<span style="color:var(--accent)">input</span> / <span style="color:var(--green)">generated</span>):</div>
<div style="display:flex;flex-wrap:wrap;gap:4px;margin:8px 0">
${seq.map((tok,i) => `<span class="token-chip ${i<INPUT_IDS.length?'input':'generated'}">${tok}</span>`).join('')}
</div>`;
  };
})();

// 11 ‚Äî KV-Cache
root.appendChild(createSection('kvcache', '11 ‚Äî KV-Cache (Efficient Inference)', 'üíæ',
`<div class="prose">During generation, K and V for past positions <strong>do not change</strong>. The KV-cache stores them to avoid recomputation:</div>
<div class="kvcache-demo">
  <div class="kvcache-step">
    <div class="kvcache-step-header">
      <span class="kvcache-step-num">Step 1</span>
      <span class="kvcache-step-desc">Prefill &#8212; process full input</span>
    </div>
    <div class="kvcache-row">
      <div class="kvcache-input-label">Input:</div>
      <div class="kvcache-tokens"><span class="autoreg-tok input">A</span><span class="autoreg-tok input">B</span><span class="autoreg-tok input">C</span></div>
    </div>
    <div class="kvcache-row">
      <div class="kvcache-input-label">Cache:</div>
      <div class="kvcache-cache-slots">
        <span class="kvcache-slot filled">K&#8320;,V&#8320;</span>
        <span class="kvcache-slot filled">K&#8321;,V&#8321;</span>
        <span class="kvcache-slot filled">K&#8322;,V&#8322;</span>
      </div>
    </div>
    <div class="kvcache-row">
      <div class="kvcache-input-label">Attn:</div>
      <div class="kvcache-attn-desc">Q&#8322; attends to <strong>all cached</strong> KV</div>
    </div>
  </div>
  <div class="kvcache-step">
    <div class="kvcache-step-header">
      <span class="kvcache-step-num">Step 2</span>
      <span class="kvcache-step-desc">Decode &#8212; only the new token!</span>
    </div>
    <div class="kvcache-row">
      <div class="kvcache-input-label">Input:</div>
      <div class="kvcache-tokens"><span class="autoreg-tok generated">D</span></div>
    </div>
    <div class="kvcache-row">
      <div class="kvcache-input-label">Cache:</div>
      <div class="kvcache-cache-slots">
        <span class="kvcache-slot cached">K&#8320;,V&#8320;</span>
        <span class="kvcache-slot cached">K&#8321;,V&#8321;</span>
        <span class="kvcache-slot cached">K&#8322;,V&#8322;</span>
        <span class="kvcache-slot filled new-slot">K&#8323;,V&#8323;</span>
      </div>
    </div>
    <div class="kvcache-row">
      <div class="kvcache-input-label">Attn:</div>
      <div class="kvcache-attn-desc">Q&#8323; attends to cached K&#8320;&#8336;&#8323;, V&#8320;&#8336;&#8323;</div>
    </div>
  </div>
  <div class="kvcache-comparison">
    <div class="kvcache-compare-item bad">
      <div class="kvcache-compare-label">Without cache</div>
      <div class="kvcache-compare-val">O(n&#178;) per step</div>
      <div class="kvcache-compare-desc">Recompute everything</div>
    </div>
    <div class="kvcache-compare-item good">
      <div class="kvcache-compare-label">With cache</div>
      <div class="kvcache-compare-val">O(n) per step</div>
      <div class="kvcache-compare-desc">Only new token</div>
    </div>
  </div>
</div>
<div class="output">KV-Cache memory per layer (this model):
  K + V: 2 √ó seq_len √ó ${C.KV} heads √ó ${C.Dh} dims √ó 4 bytes
  = ${2*C.KV*C.Dh*4} bytes per token per layer

Scaled to LLaMA-7B (d=4096, 32 layers, 32 KV heads, d_head=128):
  Per token:    ${(2*32*128*4*32/1e6).toFixed(1)} MB per token  (all layers)
  At seq=4096:  ${(2*32*128*4*32*4096/1e9).toFixed(1)} GB total KV-cache
  At seq=128K:  ${(2*32*128*4*32*131072/1e9).toFixed(1)} GB total KV-cache

This is why GQA matters ‚Äî with 8 KV heads instead of 32:
  At seq=4096:  ${(2*8*128*4*32*4096/1e9).toFixed(1)} GB  (4√ó reduction!)</div>`));

// 12 ‚Äî FLOPs
(() => {
  const S=SEQ, D=C.D, H=C.H, KV=C.KV, Dh=C.Dh, F=C.Ff;
  const qkv=S*D*(H+2*KV)*Dh*2, as=H*S*S*Dh*2, av=H*S*S*Dh*2;
  const op=S*H*Dh*D*2, ffn=S*(2*D*F+F*D)*2;
  const layer=qkv+as+av+op+ffn, total=layer*C.L+D*C.V*2;
  root.appendChild(createSection('flops', '12 ‚Äî Computation & Memory Summary', 'üìä',
`<div class="prose">Breakdown of floating-point operations for a single forward pass:</div>
<div class="flops-table">
  <div class="flops-header">
    <span class="flops-h-name">Operation</span>
    <span class="flops-h-val">FLOPs</span>
    <span class="flops-h-bar">Share</span>
  </div>
  ${[
    ['QKV Projections', qkv, '--accent'],
    ['Attention (QK&#7488;)', as, '--purple'],
    ['Attention (&#215; V)', av, '--purple'],
    ['Output Projection', op, '--accent'],
    ['SwiGLU FFN', ffn, '--green'],
  ].map(([name, val, color]) =>
    '<div class="flops-row">'
    +'<span class="flops-name">'+name+'</span>'
    +'<span class="flops-val">'+val.toLocaleString()+'</span>'
    +'<span class="flops-bar-wrap"><span class="flops-bar" style="width:'+Math.round(val/layer*100)+'%;background:var('+color+')"></span><span class="flops-pct">'+(val/layer*100).toFixed(1)+'%</span></span>'
    +'</div>'
  ).join('')}
  <div class="flops-divider"></div>
  <div class="flops-row flops-subtotal">
    <span class="flops-name">Per layer</span>
    <span class="flops-val">${layer.toLocaleString()}</span>
    <span class="flops-bar-wrap"></span>
  </div>
  <div class="flops-row">
    <span class="flops-name">&#215; ${C.L} layers</span>
    <span class="flops-val">${(layer*C.L).toLocaleString()}</span>
    <span class="flops-bar-wrap"></span>
  </div>
  <div class="flops-row">
    <span class="flops-name">+ LM Head</span>
    <span class="flops-val">${(D*C.V*2).toLocaleString()}</span>
    <span class="flops-bar-wrap"></span>
  </div>
  <div class="flops-divider thick"></div>
  <div class="flops-row flops-total">
    <span class="flops-name">Total</span>
    <span class="flops-val">${total.toLocaleString()} FLOPs</span>
    <span class="flops-bar-wrap"></span>
  </div>
</div>
<div class="scaling-insight">
  <div class="scaling-insight-title">Scaling insight</div>
  <div class="scaling-cards">
    <div class="scaling-card">
      <div class="scaling-card-head" style="color:var(--purple)">Attention</div>
      <div class="scaling-card-formula">O(n&#178; &#183; d)</div>
      <div class="scaling-card-desc">Quadratic in sequence length</div>
    </div>
    <div class="scaling-card">
      <div class="scaling-card-head" style="color:var(--green)">FFN</div>
      <div class="scaling-card-formula">O(n &#183; d&#178;)</div>
      <div class="scaling-card-desc">Quadratic in model dimension</div>
    </div>
    <div class="scaling-card">
      <div class="scaling-card-head" style="color:var(--orange)">Crossover</div>
      <div class="scaling-card-formula">seq &#8776; d_model</div>
      <div class="scaling-card-desc">Short seq &#8594; FFN dominates; Long seq &#8594; Attention dominates</div>
    </div>
  </div>
</div>`));
})();

// 13 ‚Äî Summary
(() => {
  const takeaways = [
    ['Everything is matmuls', 'Linear projections and dot products ‚Äî GPUs are optimized for exactly this.', '--accent'],
    ['RoPE encodes position via rotation', 'Q¬∑K dot products naturally depend on relative position. No learnable parameters.', '--cyan'],
    ['GQA halves KV-cache memory', 'Multiple query heads share K,V heads. Same quality, half the memory at inference.', '--green'],
    ['SwiGLU > ReLU', 'Learned gating selects which features to activate. 3 matrices, better expressivity.', '--orange'],
    ['RMSNorm is the new standard', 'Simpler than LayerNorm (no mean, no bias), equivalent quality.', '--purple'],
    ['KV-cache is essential', 'Without it, generation cost is O(n¬≤) per token. With it, O(n).', '--red'],
    ['Causal mask = decoder', 'Each position only sees the past ‚Äî this is what makes it autoregressive.', '--text-bright'],
  ];
  root.appendChild(createSection('summary', '13 ‚Äî Summary & Key Takeaways', 'üéì',
`<div>${takeaways.map(([t,d,c],i) =>
`<div class="takeaway" style="background:rgba(${c==='--accent'?'88,166,255':c==='--cyan'?'57,210,192':c==='--green'?'63,185,80':c==='--orange'?'210,153,34':c==='--purple'?'188,140,255':c==='--red'?'248,81,73':'230,237,243'},0.04);border:1px solid rgba(${c==='--accent'?'88,166,255':c==='--cyan'?'57,210,192':c==='--green'?'63,185,80':c==='--orange'?'210,153,34':c==='--purple'?'188,140,255':c==='--red'?'248,81,73':'230,237,243'},0.13)">
  <span class="takeaway-num" style="color:var(${c})">${i+1}.</span>
  <div><div class="takeaway-title" style="color:var(${c})">${t}</div><div class="takeaway-desc">${d}</div></div>
</div>`).join('')}</div>
<div class="footer">Built with typed arrays. No frameworks, no magic ‚Äî just math.</div>`, true));
})();
</script>
</body>
</html>
